<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on xyenchi&#39;s blog</title>
    <link>https://xyenchi.github.io/posts/</link>
    <description>Recent content in Posts on xyenchi&#39;s blog</description>
    <image>
      <title>xyenchi&#39;s blog</title>
      <url>https://xyenchi.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://xyenchi.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.155.3</generator>
    <language>en</language>
    <atom:link href="https://xyenchi.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RISC-V Vector 或 SIMD 类似拓展的应用举例子说明</title>
      <link>https://xyenchi.github.io/posts/risc-v-vector--%E6%88%96-simd-%E7%B1%BB%E4%BC%BC%E6%8B%93%E5%B1%95%E7%9A%84%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xyenchi.github.io/posts/risc-v-vector--%E6%88%96-simd-%E7%B1%BB%E4%BC%BC%E6%8B%93%E5%B1%95%E7%9A%84%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/</guid>
      <description>&lt;h3 id=&#34;线性代数部分&#34;&gt;线性代数部分&lt;/h3&gt;
&lt;h4 id=&#34;专有名词&#34;&gt;专有名词：&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/zh-cn/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84&#34;&gt;线性方程组&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zh.wikipedia.org/zh-cn/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84#%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84&#34;&gt;齐次线性方程组&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A2%9E%E5%B9%BF%E7%9F%A9%E9%98%B5&#34;&gt;增广矩阵&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;还没有想好次级标题叫什么名字&#34;&gt;还没有想好次级标题叫什么名字&lt;/h4&gt;
&lt;p&gt;不知道有没有必要从线性方程的求解开始讲起，简单带过一下好了。想象有很多未知数，如果没有限制条件，未知数的结果就想怎么编就怎么编，但是如果用方程组来当它们的限制条件，就可以缩小范围。用线性代数的方法求解就是，把未知数的位置对齐，将系数收集起来，称之为系数矩阵，对系数矩阵进行行变换化简，得到线性无关行向量个数，也就是矩阵的秩。秩小于未知数个数时，相当于限制条件没有太多，可以在一定范围内瞎编。而秩等于未知数个数时，想方便理解的话就还原一下原本的方程，如果是齐次线性方程，最后一行的未知数 x 常数之后还是等于0, 只能未知数自己也是0。以前学的教材上还有增广矩阵这个概念用来求等式右边不为0的情况，但是规律公式啥的都很难记，还是行变换之后想象一下原本的方程简单。&lt;/p&gt;
&lt;h3 id=&#34;电路部分线性齐次&#34;&gt;电路部分（线性齐次）&lt;/h3&gt;
&lt;h4 id=&#34;专有名词-1&#34;&gt;专有名词：&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/zh-hans/%E5%9F%BA%E7%88%BE%E9%9C%8D%E5%A4%AB%E9%9B%BB%E8%B7%AF%E5%AE%9A%E5%BE%8B#%E5%9F%BA%E7%88%BE%E9%9C%8D%E5%A4%AB%E9%9B%BB%E6%B5%81%E5%AE%9A%E5%BE%8B&#34;&gt;基尔霍夫电流定律&lt;/a&gt;
&lt;a href=&#34;https://zh.wikipedia.org/zh-hans/%E5%9F%BA%E7%88%BE%E9%9C%8D%E5%A4%AB%E9%9B%BB%E8%B7%AF%E5%AE%9A%E5%BE%8B#%E5%9F%BA%E7%88%BE%E9%9C%8D%E5%A4%AB%E9%9B%BB%E5%A3%93%E5%AE%9A%E5%BE%8B&#34;&gt;基尔霍夫电压定律&lt;/a&gt;
&lt;a href=&#34;https://zh.wikipedia.org/zh-hans/%E7%AF%80%E9%BB%9E%E5%88%86%E6%9E%90&#34;&gt;节点分析&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;举个例子&#34;&gt;举个例子：&lt;/h4&gt;
&lt;p&gt;本来是想拿个电路图举例子的，但是发现博客没调好，显示不了图片。等下一次心血来潮的时候修一修吧。&lt;br&gt;
大致过程就是，选一个参考节点，把所有节点标个号方便表示，给每一条支路都标个方向。找出受控源，列出支路方程，受控源正负极相连的方向如果跟你标的方向相同就写负号，相反就写正号。列出节点电压方程。改写成矩阵形式。就变成了一个方程组解的问题。&lt;/p&gt;
&lt;h3 id=&#34;电路部分线性非齐次&#34;&gt;电路部分（线性非齐次）&lt;/h3&gt;
&lt;p&gt;要写的也太多了。。。再说吧。&lt;/p&gt;
&lt;h4 id=&#34;专有名词-2&#34;&gt;专有名词：&lt;/h4&gt;
&lt;h4 id=&#34;举个例子-1&#34;&gt;举个例子：&lt;/h4&gt;
&lt;h3 id=&#34;关于射频仿真软件&#34;&gt;关于射频仿真软件&lt;/h3&gt;
&lt;p&gt;之前在电子厂干天线的测试和量产前期的失效分析，因为看不到什么前途就在闲的时候看了一些天线仿真教学，但是也没太深入学习就跑路了，机缘巧合之下转行搞计算机。在开始学仿真的时候，学习到的就是不同的电尺寸选择的算法会不一样，还接触到了边界条件这些很有意思的概念。在学习RISCV相关的知识的时候，经常看到的例子就是计算RGB, 但是脑子里好像又有一些矩阵的其他用法，心血来潮，写下这篇博客，如果以后能学习到更多，那本文就是挖的坑，有空就来填，如果以后真的转行成功，在其他方向深入，那本文就是对过去的总结。&lt;/p&gt;</description>
    </item>
    <item>
      <title>RVV intrinsic的实现分析</title>
      <link>https://xyenchi.github.io/rvv_intrinsic_analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xyenchi.github.io/rvv_intrinsic_analysis/</guid>
      <description>&lt;p&gt;虽然标题叫分析，但现在已经变成了大量注释内容整合的形状，可能得改名为笔记。&lt;br&gt;
既然我第一行就写明了，那么便不是标题党。&lt;br&gt;
之所以不能叫分析，当然是自己回头看一遍都没看懂在写啥。&lt;/p&gt;
&lt;h3 id=&#34;包含的文件&#34;&gt;包含的文件&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/iterator.md&#34;&gt;iterator.md&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/constraint.md&#34;&gt;constraint.md&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/riscv-c.cc&#34;&gt;riscv-c.cc&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/riscv-protos.h&#34;&gt;riscv-protos.h&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/riscv-vector-builtins-bases.cc&#34;&gt;riscv-vector-builtins-bases.cc&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/riscv-vector-builtins-bases.h&#34;&gt;riscv-vector-builtins-bases.h&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/riscv-vector-builtins-functions.def&#34;&gt;riscv-vector-builtins-functions.def&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/riscv-vector-builtins-shapes.cc&#34;&gt;riscv-vector-builtins-shapes.cc&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/riscv-vector-builtins-shapes.h&#34;&gt;riscv-vector-builtins-shapes.h&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/riscv-vector-builtins-types.def&#34;&gt;riscv-vector-builtins-types.def&lt;/a&gt; &lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/riscv-vector-builtins.cc&#34;&gt;riscv-vector-builtins.cc&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/riscv-vector-builtins.h&#34;&gt;riscv-vector-builtins.h&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/riscv.md&#34;&gt;riscv.md&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/vector-iterators.md&#34;&gt;vector-iterators.md&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/gcc-mirror/gcc/blob/master/gcc/config/riscv/vector.md&#34;&gt;vector.md&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;acronyms&#34;&gt;Acronyms&lt;/h3&gt;
&lt;p&gt;QI: 8 bits&lt;br&gt;
HI: 16 bits&lt;br&gt;
SI: 32 bits&lt;br&gt;
DI: 64 bits&lt;br&gt;
把一个word（即 32 bit 当成计量单位）四分之一（quarter）、二分之一（half）、双倍（double）。&lt;/p&gt;
&lt;h4 id=&#34;iteratormd&#34;&gt;iterator.md&lt;/h4&gt;
&lt;p&gt;使用lisp声明通用寄存器位宽定义迭代器（iterator）名称&lt;/p&gt;
&lt;h4 id=&#34;constraintmd&#34;&gt;constraint.md&lt;/h4&gt;
&lt;p&gt;在 match_operand 中，可以指定操作数约束(operand  constraint)。&lt;br&gt;
约束(constraint)对断言(predicate)所允许的操作数进行更详细的描述。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;约束条件可以定义操作数是否可以使用寄存器以及使用何种寄存器。&lt;/li&gt;
&lt;li&gt;说明操作数是否可以是一个内存引用以及其地址类型。&lt;/li&gt;
&lt;li&gt;描述该操作数是都可以是一个立即数常量(immediate)以及其可能的值。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GCC 中的约束(constraint)使用字符串(string)表示。&lt;br&gt;
以下是常见用法（部分夹带RISC-V私货方便自己查询）：&lt;br&gt;
&lt;em&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/em&gt;:   memory operand, autoincrement addressing type, including preincrement and postincrement.&lt;br&gt;
&lt;em&gt;&lt;strong&gt;f&lt;/strong&gt;&lt;/em&gt;:   floating-point register&lt;br&gt;
&lt;em&gt;&lt;strong&gt;g&lt;/strong&gt;&lt;/em&gt;:   general register, memory or integer immediate constant.&lt;br&gt;
&lt;em&gt;&lt;strong&gt;i&lt;/strong&gt;&lt;/em&gt;:   Integer immediate operand, sign constant when and after compilering.&lt;br&gt;
&lt;em&gt;&lt;strong&gt;j&lt;/strong&gt;&lt;/em&gt;:   SIBCALL_REGS&lt;br&gt;
&lt;em&gt;&lt;strong&gt;l&lt;/strong&gt;&lt;/em&gt;:   JALR_REGS&lt;br&gt;
&lt;em&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/em&gt;:   known value integer immediate operand&lt;br&gt;
&lt;em&gt;&lt;strong&gt;p&lt;/strong&gt;&lt;/em&gt;:   memory address operand&lt;br&gt;
&lt;em&gt;&lt;strong&gt;x&lt;/strong&gt;&lt;/em&gt;:   all operand&lt;br&gt;
&lt;em&gt;&lt;strong&gt;I&lt;/strong&gt;&lt;/em&gt;:   12-bit integer signed immediate
&lt;em&gt;&lt;strong&gt;J&lt;/strong&gt;&lt;/em&gt;:   integer zero&lt;br&gt;
&lt;em&gt;&lt;strong&gt;K&lt;/strong&gt;&lt;/em&gt;:   5-bit unsigned immediate for CSR access instructions   &lt;br&gt;
&lt;em&gt;&lt;strong&gt;L&lt;/strong&gt;&lt;/em&gt;:   U-type 20-bit signed immediate   &lt;br&gt;
&lt;em&gt;&lt;strong&gt;Ds3&lt;/strong&gt;&lt;/em&gt;:   1, 2 or 3 immediate&lt;br&gt;
&lt;em&gt;&lt;strong&gt;DsS&lt;/strong&gt;&lt;/em&gt;:   31 immediate&lt;br&gt;
&lt;em&gt;&lt;strong&gt;DsD&lt;/strong&gt;&lt;/em&gt;:   63 immediate&lt;br&gt;
&lt;em&gt;&lt;strong&gt;DbS&lt;/strong&gt;&lt;/em&gt;:&lt;br&gt;
&lt;em&gt;&lt;strong&gt;DnS&lt;/strong&gt;&lt;/em&gt;:&lt;br&gt;
&lt;em&gt;&lt;strong&gt;D03&lt;/strong&gt;&lt;/em&gt;:   0, 1, 2 or 3 immediate&lt;br&gt;
&lt;em&gt;&lt;strong&gt;DsA&lt;/strong&gt;&lt;/em&gt;:   0 - 10 immediate&lt;br&gt;
&lt;em&gt;&lt;strong&gt;G&lt;/strong&gt;&lt;/em&gt;:&lt;br&gt;
&lt;em&gt;&lt;strong&gt;A&lt;/strong&gt;&lt;/em&gt;:   An address that is held in a general-purpose register.&lt;br&gt;
&lt;em&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/em&gt;:   A constraint that matches an absolute symbolic address.&lt;br&gt;
&lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;&lt;/em&gt;:   A PLT-indirect call address.&lt;br&gt;
&lt;em&gt;&lt;strong&gt;T&lt;/strong&gt;&lt;/em&gt;:&lt;br&gt;
&lt;em&gt;&lt;strong&gt;vr&lt;/strong&gt;&lt;/em&gt;:   vector register   &lt;br&gt;
&lt;em&gt;&lt;strong&gt;vd&lt;/strong&gt;&lt;/em&gt;:   vector register except mask register&lt;br&gt;
&lt;em&gt;&lt;strong&gt;vm&lt;/strong&gt;&lt;/em&gt;:   vector mask register&lt;br&gt;
&lt;em&gt;&lt;strong&gt;vp&lt;/strong&gt;&lt;/em&gt;:   poly int&lt;br&gt;
&lt;em&gt;&lt;strong&gt;vu&lt;/strong&gt;&lt;/em&gt;:   undefined vector value&lt;br&gt;
&lt;em&gt;&lt;strong&gt;vi&lt;/strong&gt;&lt;/em&gt;:   vector 5-bit signed immediate&lt;br&gt;
&lt;em&gt;&lt;strong&gt;vj&lt;/strong&gt;&lt;/em&gt;:   vector negated 5-bit signed immediate&lt;br&gt;
&lt;em&gt;&lt;strong&gt;vk&lt;/strong&gt;&lt;/em&gt;:   vector 5-bit unsigned immediate&lt;br&gt;
&lt;em&gt;&lt;strong&gt;Wc0&lt;/strong&gt;&lt;/em&gt;:   vector of immediate all zeros&lt;br&gt;
&lt;em&gt;&lt;strong&gt;Wc1&lt;/strong&gt;&lt;/em&gt;:   vector of immediate all ones&lt;br&gt;
&lt;em&gt;&lt;strong&gt;Wb1&lt;/strong&gt;&lt;/em&gt;:   BOOL vector of {&amp;hellip;,0,&amp;hellip;0,1}&lt;br&gt;
&lt;em&gt;&lt;strong&gt;Wdm&lt;/strong&gt;&lt;/em&gt;:   Vector duplicate memory operand&lt;br&gt;
&lt;em&gt;&lt;strong&gt;th_f_fmv&lt;/strong&gt;&lt;/em&gt;:   floating-point register for XTheadFmv&lt;br&gt;
&lt;em&gt;&lt;strong&gt;th_r_fmv&lt;/strong&gt;&lt;/em&gt;:   integer register for XTheadFmv&lt;br&gt;
&lt;em&gt;&lt;strong&gt;vmWc1&lt;/strong&gt;&lt;/em&gt;:&lt;br&gt;
vector mask register + a vector of immediate all ones&lt;br&gt;
&lt;em&gt;&lt;strong&gt;rK&lt;/strong&gt;&lt;/em&gt;:&lt;br&gt;
register operand using general register + 5-bit unsigned immediate for CSR access instructiosn&lt;/li&gt;
&lt;li&gt;约束修饰字符 (Constraint Modifier Characters)&lt;br&gt;
&lt;em&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;/em&gt;:操作数只写&lt;br&gt;
&lt;em&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;/em&gt;:操作可读可写&lt;br&gt;
&lt;em&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;/em&gt;:在某些约束选择(constraint alternative)中，该操作数是前面某个clobber的操作数，作为指令的输入操作数，该操作数在指令结束之前它的值已经被修改，因此，该操作数可能不在原来使用的寄存器或内存地址中存储   &lt;br&gt;
&lt;em&gt;&lt;strong&gt;%&lt;/strong&gt;&lt;/em&gt;:可交换，该操作数及其之后的操作数可以进行交换&lt;br&gt;
eg. 操作数1的约束为 &amp;lsquo;%0&amp;rsquo;，表示与操作数0的约束相同。&lt;br&gt;
&lt;em&gt;&lt;strong&gt;#&lt;/strong&gt;&lt;/em&gt;:直到逗号的所有字符在进行约束处理时将被忽略，这些字符只对寄存器选择起作用&lt;br&gt;
&lt;em&gt;&lt;strong&gt;*:&lt;/strong&gt;&lt;/em&gt; 直到逗号的所有字符在进行约束处理是将被忽略，这些字符在寄存器选择是也将被忽略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;riscv-ccc&#34;&gt;riscv-c.cc&lt;/h4&gt;
&lt;p&gt;riscv intrinsic 相关。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
