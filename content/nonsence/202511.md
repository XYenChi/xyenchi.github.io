---
title: "十一月工作月更"
date: "2025-11-15T11:30:03+00:00"
draft: false
---
### 社区活动
参加宁夏理工的 RISC-V 校园行。宁夏理工的社区氛围不错，不愧是之前举办过安同校园行的学校。   
分享过程中发现不乏大一新生来参加活动，Slides 加入更多内容的决定是对的。后续可能更新一些如何区分指令集架构，放入教程链接。   
参加应急管理大学 RISC-V 校园行，没啥活力，结束后有签到领学分环节。   

### RIF
还是需要看 IEEE 754 获取一些前置知识，之前调用 roundToInt 函数的方法不对。fadd函数里面还套了一层。   
在 RIF 的头文件中使用函数改写 softfloat_roundingMode 即可。   

#### vrgather
当 vlen = 128 bit，sew = 64 bit时，因为进行测试设置的 vl 是5，vlmax = 2，小于 vl，所以 vsetvl 指令一直非法，vl 没有设置成功，intrinsic 的 c 测例
中多进行了循环。   
在我看来别的指令也应该收到影响，但是由于复用 spike 头文件中并没有与 i 相关的展开，掩盖了这一可能的问题，但也可能是我没想清楚，等待复议。   

#### spike
```C++
template<class T> T& vectorUnit_t::elt(reg_t vReg, reg_t n, bool UNUSED is_write) {
  assert(vsew != 0);
  assert((VLEN >> 3)/sizeof(T) > 0);
  reg_t elts_per_reg = (VLEN >> 3) / (sizeof(T));
  vReg += n / elts_per_reg;
  n = n % elts_per_reg;
#ifdef WORDS_BIGENDIAN
  // "V" spec 0.7.1 requires lower indices to map to lower significant
  // bits when changing SEW, thus we need to index from the end on BE.
  n ^= elts_per_reg - 1;
#endif
  reg_referenced[vReg] = 1;

  if (unlikely(p->get_log_commits_enabled() && is_write))
    p->get_state()->log_reg_write[((vReg) << 4) | 2] = {0, 0};

  T *regStart = (T*)((char*)reg_file + vReg * (VLEN >> 3));
  return regStart[n];
}
```
Spike的实现建立在模拟器本身需要找到向量寄存器的位置，但 RIF 并不需要。所以简化为以下函数模板：   
```C++
template <class T> T& elt(void* vReg, uint64_t n, bool is_write = false) {
	T* vRegPtr = reinterpret_cast<T*>(vReg);
	return vRegPtr[n];
}
```
传入 void 指针和第几个元素，根据对应的 sew 返回数组元素。   
在编译阶段，头文件 switch 的 case 全部都会进行判断，所以需要 void 指针。   
