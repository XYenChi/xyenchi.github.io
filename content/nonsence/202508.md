---
title: "八月工作月更"
date: "2025-08-15T11:30:03+00:00"
draft: false
---

### 有关项目 ###
近期发现使用宏定义的方法满足 intrinsic function 的 rounding mode 需要是 unsign constant 的要求会导致传入的 rounding mode 是 0.
在群友帮助下改为使用枚举四种 fixed-point 和五种 float point rounding mode的方法，对原本代码进行了大量重构。
在 fix-point 的 vxrm rounding 中测试十分成功，在 float point 中测试不成功。
想要抄袭 spike 写法，但没看懂如何实现的，我根本没找到在哪实现了（划掉。只有一个读 frm 的过程。
自己这边调用 berkerly softfloat librar 的时候待 rounding 的值不满足任何一个 condition，没有任何改变地退出了。

### C++ ###
`uint16_t` 16 bit 无符号整型。
`uint_fast16_t` C++ 11之后最快的可用无符号整型，至少 16 bit。

C 和 C++ 有 likely() 和 unlikely() 的宏给编译器大概率为真/不为真的提示。

`__attribute__ ((__packed__))` 表示不对齐，以实际使用长度存储。

### 技术分享 ###
今日为了解决 float point rounding mode 的问题对 ieee754 2008 、berkely softfloat、spike 和 qemu 有关内容进行了少量研究。
[slides link](https://docs.google.com/presentation/d/1c4s0P6chEdc6m7P4-OPWwJ9EYBh0mKjD3JV4IsWcrVA/edit?usp=sharing)
主要发现是 RIF 对 float16 和 float32 进行运算的数值都不在需要 rounding 的范围内。
qemu 会有把 float16 和 float32 变为 float64 处理的过程。
