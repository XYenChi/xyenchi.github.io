<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RVFA课程学习笔记 | xyenchi's blog</title><meta name=keywords content><meta name=description content="timeline
1980:   start around, RISC-V is the fifth generation of a research project.
2010:   RISC-V is the result of an evolving project.
2011:   The first version of the RISC-V ISA was released.
name
the number just after &ldquo;RV&rdquo;:
XLEN: in the Unprivileged Specification document.
represents the width of registers and not the width of the instructions. Not all instruction width are allowed, only multiple of 16 bits wide.
for example, the 32 of RV32I.    
RV64G:
RV64IMAFDZicsr_Zifencei"><meta name=author content="xyenchi"><link rel=canonical href=https://xyenchi.github.io/note/rvfa%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://xyenchi.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xyenchi.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xyenchi.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://xyenchi.github.io/apple-touch-icon.png><link rel=mask-icon href=https://xyenchi.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://xyenchi.github.io/note/rvfa%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://xyenchi.github.io/note/rvfa%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="xyenchi's blog"><meta property="og:title" content="RVFA课程学习笔记"><meta property="og:description" content="timeline 1980: start around, RISC-V is the fifth generation of a research project.
2010: RISC-V is the result of an evolving project.
2011: The first version of the RISC-V ISA was released.
name the number just after “RV”: XLEN: in the Unprivileged Specification document. represents the width of registers and not the width of the instructions. Not all instruction width are allowed, only multiple of 16 bits wide.
for example, the 32 of RV32I. RV64G:
RV64IMAFDZicsr_Zifencei"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="note"><meta property="og:image" content="https://xyenchi.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://xyenchi.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="RVFA课程学习笔记"><meta name=twitter:description content="timeline
1980:   start around, RISC-V is the fifth generation of a research project.
2010:   RISC-V is the result of an evolving project.
2011:   The first version of the RISC-V ISA was released.
name
the number just after &ldquo;RV&rdquo;:
XLEN: in the Unprivileged Specification document.
represents the width of registers and not the width of the instructions. Not all instruction width are allowed, only multiple of 16 bits wide.
for example, the 32 of RV32I.    
RV64G:
RV64IMAFDZicsr_Zifencei"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://xyenchi.github.io/note/"},{"@type":"ListItem","position":2,"name":"RVFA课程学习笔记","item":"https://xyenchi.github.io/note/rvfa%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RVFA课程学习笔记","name":"RVFA课程学习笔记","description":"timeline 1980: start around, RISC-V is the fifth generation of a research project.\n2010: RISC-V is the result of an evolving project.\n2011: The first version of the RISC-V ISA was released.\nname the number just after \u0026ldquo;RV\u0026rdquo;: XLEN: in the Unprivileged Specification document. represents the width of registers and not the width of the instructions. Not all instruction width are allowed, only multiple of 16 bits wide.\nfor example, the 32 of RV32I. RV64G:\nRV64IMAFDZicsr_Zifencei\n","keywords":[],"articleBody":"timeline 1980: start around, RISC-V is the fifth generation of a research project.\n2010: RISC-V is the result of an evolving project.\n2011: The first version of the RISC-V ISA was released.\nname the number just after “RV”: XLEN: in the Unprivileged Specification document. represents the width of registers and not the width of the instructions. Not all instruction width are allowed, only multiple of 16 bits wide.\nfor example, the 32 of RV32I. RV64G:\nRV64IMAFDZicsr_Zifencei\nintruction encode RV32I/RV64I:\nFor 32-bit(or higher) instructions, the first 2 bits will be 11.\nThe other three quadrants (00, 01, 10) are used by the 16-bit Compressed Instructions.\nlength RISC-V instructions can be any multiple of 16 bits wide (although most are 32 bits wide) and the information on their length is contained in their major opcode.\nmajor opcode the first 7 bits of the instruction, identifying the intruction.\nminor opcode name funct7 or funct3. note: LUI, AUIPC and JAL contain no minor opcode.\nfunct7 occupies the last 7 bits of the R type instruction\nfunct3 always occupies bits 12 to 14\nformats instruction type formats defined by the encoding of immediate.\nR, I, S, B, U, J\nR type:\n“Register” type - this format is used by arithmetic register-register operations such as ADD, SUB, boolean operations, and shifts.\nThe R-type instruction format is the only one to encode three different registers.\nEncode 3 registers, 0 immediate, 2 minor opcode fields, 1 major opcode field.\nI type:\n“Immediate” type - this format is used by arithmetic, logic, and shift operations with immediates, jump and link register, environment calls, and LOAD instructions. (have the longest immediate bits, 11 bits, from 20 to 31)\nnot the only instruction to encode immediate but R type.\ngeneric register-immediate instruction\n12 bits immediate, 5 bits rs1, 3 bits funct3, 5 bits rd and 7 bits opcode. generic LOAD instruction\n12 bits immediate, 5 bits rs1, 3 bits funct3, 5 bits rd and 7 bits opcode. JALR instruction\n12 bits immediate, 5 bits rs1, 3 bits funct3, 5 bits rd and 7 bits opcode. FENCE instruction\n4 bits fm, 1 bit PI, PO, PR, PW, SI, SO, SR and SW, 5 bits rs1, 3 bits funct3, 5 bits rd and 7 bits opcode. Environment instruction\n12 bits immediate, 5 bits rs1, 3 bits funct3, 5 bits rd and 7 bits opcode. EBREAK returns control to the debugging environment.\nECALL requests privileged information to the execution environment in ways defined by the applicable EEI. pseudoinstructions\nNOP, LI, MV, SEXT.W, SEQZ, The FENCE instruction without arguments is an alias for FENCE iorw iorw, JR, JALR and RET.\nS type: “Store” type - this format is used by the STORE instructions. same structure as B B type: “Branch” type - this format is used by the BRANCH instructions.\nsame structure as S\nU type: “Upper Immediate” type - this format is used by instructions that use upper immediates (LUI and AUIPC).\nsame structure as J\n20 bits immediates, 5 bits rd and 7 bits opcode.\nAUIPC rd imm “add upper immediate to PC” stores the value of PC in rd and adds the shifted imm to it.\nLUI rd imm “load upper immediate” set rd to the shifted imm.\nJ type: “Jump” type - this format is used by the JAL (jump and link) instruction. same structure as U\nJAL rd imm “jump and link”:\nsave PC+4, the return address associated with the JAL instruction, in rd.\nAdd imm to PC. summary The J-type instructions have the same structure as the U-type instructions, only differing by how the immediate is encoded.\nregister More: RISC processors usually have more than eight general-purpose registers.\nmemory Memory access is limited to Load and Store instructions.\nvirtual memory single address space divided into pages, 4 kilobytes long sections of continuous memory. isolates software running above it requiring addresses to be translated by the operating system. feature modular: base(I must exist) + extensions\nspec ISA specifications: priviledged + unprivileged\nunprivileged: Base ISA and ISA extensions\nprivileged: interrupts, exceptions, virtual memory management, and physical memory protection etc\nsoftware stack ABI(specification) -\u003e application\nSBI(specification) -\u003e supervisor(application)\nHBI(specification) -\u003e hypervisor(application)\nAEE\nSEE\nHEE\nRISC-V ISA privilegde mode M (machine) mode\nS (supervisor) mode\nU (user) mode\ntraps contained trap Handled by the software that raise it.\nExecution resumes after resolution.\nrequested trap request to execution environment.\ninvisible trap raised and handled by the execution environment.\nnot visible by the software running inside it.\nfatal trap cause the execution environment to stop exeception.\nCSR Acronyms WPRI: write preserve, read ignore.\nWLRL: write legal, read legal.\nWARL: write any, read legal.\nMachine Level ISA mstatus register.\nalways 64 bits wide. RV32 machine implement it as two separate CSRs (mstatus and mstatush)\nxIE: x mode Interrupt Enabled\nxPIE: x mode Previous Interrupt Enabled\nxPP: x mode Previous Privilege x can be M or S mode\nmip Machine Interrupt Pending WARL register\nmie Machine Interrupt Enable WARL register\nmepc Machine Exception Program Counter WARL register\nmcause Machine Cause WLRL register\nmtval Machine Trap Value register\nmconfigptr Machine Configuration Pointer address\nI-type format instructions to enable trap handling MRET: M mode return\nWFI: Wait for Interrupt\nSupervisor level sstatus, sip, sie, scause same as mstatus, mip, mie, mcause.\nsepc, stval same as mepc and mtval, except they contain virtual rather than physical memory addresses.\nsatp Supervisor Address Translation and Protection register has no Machine Level equivalent it is used for memory address translation.\nMODE\nASID\nAddress Space IDentifier\nPPN\nPhysical Page Number\nHypervisor memory model RVWMO RISC-V Weak Memory Ordering\nPMP Physical Memory Protection\nAssembly interrupt handler __attribute_((interrupt(“machine”)))\n__attribute_((interrupt(“supervisor”)))\ncall convention register s0 is callee register, the function that is called should be responsible for (re)storing it.\nGCC compiler flags code model -mcmodel:\n-mcmodel=medlow:\naddress range is within 2 GiB in the absolute range between -2 GiB and +2 GiB\n-mcmodel=medany:\nan address range within 2 GiB but position-independent\nlinker relaxation:\nused by the linker to efficiently load symbol addresses.\n-mrelax:enable linker relaxations\n-mno-relax:disable linker relaxations\nLLVM operate system AMO R-type instruction format.\natomic swap instrution can be used to atomically acquire and release locks.\natomic load-and-reserve and store-conditional instructions can be used to implement semaphores.\nHigh-Level Atomic API Mutex A mutex is a lock that provides mutual exclusion to a shared resource.\nA spinlock is a lock that uses busy waiting to synchronize access to a shared resource.\nSemaphores Data structure. A semaphore is one synchronization mechanism used in most OSes to control access to shared resources.\nMonitors Send/Recv Low-Level Atomic Ops Load/store Interrupt disable/enable Test\u0026Set Other atomic instructions Interrupts(I/O), Multiprocessors and CPU scheduling Synchronization Load-linked/store-conditional(LL/SC):\nGenerally, LR will return the current value of an address, and a subsequent SC to the same address will store a new value only if no updates have occurred to the same address since the last LR.\nLoad-reserved/store-conditional(LR/SC):\nIf the SC.W succeeds, the instruction writes the word in rs2 to memory, and it writes zero to rd. If the SC.W fails, the instruction does not write to memory, and it writes a nonzero value to rd.\ngeneral purpose operate system SMAP Supervisor Mode Access Prevention\nSMAP is a hardware-based feature that prevents the kernel from accessing user-level memory.\nSMEP Supervisor Mode Execution Prevention\nUnlike SMAP, which can be configured, SMEP is always enabled in RISC-V when paged virtual memory is enabled.\ntips The OpenRISC ISA is the first open ISA. There are instruction set specifications for 32-bit and 64-bit address spaces, but the RISC-V design allows for any bit-width address spaces. AUIPC+JALR or LUI+JALR combo make absolute addressing achievable, so a program can unconditionally jump to any absolute address in the whole memory address space. not recommend. RISC-V support hypervisor nesting(running a hypervisor on top of another hypervisor) with the Hypervisor extension. ","wordCount":"1293","inLanguage":"en","image":"https://xyenchi.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"xyenchi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xyenchi.github.io/note/rvfa%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"xyenchi's blog","logo":{"@type":"ImageObject","url":"https://xyenchi.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xyenchi.github.io/ accesskey=h title="xyenchi's blog (Alt + H)">xyenchi's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xyenchi.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://xyenchi.github.io/record/ title=Record><span>Record</span></a></li><li><a href=https://xyenchi.github.io/perf/ title=Perf><span>Perf</span></a></li><li><a href=https://xyenchi.github.io/note/ title=Note><span>Note</span></a></li><li><a href=https://xyenchi.github.io/nonsence/ title=Nonsence><span>Nonsence</span></a></li><li><a href=https://xyenchi.github.io/novel/ title=Novel><span>Novel</span></a></li><li><a href=https://xyenchi.github.io/about/ title=About><span>About</span></a></li><li><a href=https://xyenchi.github.io/friends/ title=Friends><span>Friends</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">RVFA课程学习笔记</h1><div class=post-meta>7 min&nbsp;·&nbsp;1293 words&nbsp;·&nbsp;xyenchi</div></header><div class=post-content><h3 id=timeline>timeline<a hidden class=anchor aria-hidden=true href=#timeline>#</a></h3><p><strong>1980</strong>: start around, RISC-V is the fifth generation of a research project.<br><strong>2010</strong>: RISC-V is the result of an evolving project.<br><strong>2011</strong>: The first version of the RISC-V ISA was released.</p><h3 id=name>name<a hidden class=anchor aria-hidden=true href=#name>#</a></h3><p>the number just after &ldquo;RV&rdquo;:
<em><strong>XLEN</strong></em>: in the Unprivileged Specification document.
represents <em><strong>the width of registers and not the width of the instructions</strong></em>. Not all instruction width are allowed, only multiple of 16 bits wide.<br>for example, the 32 of RV32I.<br><em><strong>RV64G</strong></em>:<br>RV64IMAFDZicsr_Zifencei</p><h3 id=intruction>intruction<a hidden class=anchor aria-hidden=true href=#intruction>#</a></h3><h4 id=encode>encode<a hidden class=anchor aria-hidden=true href=#encode>#</a></h4><p>RV32I/RV64I:<br>For 32-bit(or higher) instructions, the first 2 bits will be 11.<br>The other three quadrants (00, 01, 10) are used by the 16-bit Compressed Instructions.</p><h4 id=length>length<a hidden class=anchor aria-hidden=true href=#length>#</a></h4><p>RISC-V instructions can be any multiple of 16 bits wide (although most are 32 bits wide) and the information on their length is contained in their major opcode.</p><h4 id=major-opcode>major opcode<a hidden class=anchor aria-hidden=true href=#major-opcode>#</a></h4><p>the first 7 bits of the instruction, identifying the intruction.</p><h4 id=minor-opcode>minor opcode<a hidden class=anchor aria-hidden=true href=#minor-opcode>#</a></h4><p>name funct7 or funct3.<br><em><strong>note</strong></em>: LUI, AUIPC and JAL contain no minor opcode.<br><em><strong>funct7</strong></em> occupies the last 7 bits of the R type instruction<br><em><strong>funct3</strong></em> always occupies bits 12 to 14</p><h4 id=formats>formats<a hidden class=anchor aria-hidden=true href=#formats>#</a></h4><p>instruction type formats defined by the <em><strong>encoding of immediate</strong></em>.<br>R, I, S, B, U, J<br><em><strong>R</strong></em> type:<br>&ldquo;Register&rdquo; type - this format is used by arithmetic register-register operations such as ADD, SUB, boolean operations, and shifts.<br>The R-type instruction format is the only one to encode three different registers.<br>Encode 3 registers, 0 immediate, 2 minor opcode fields, 1 major opcode field.<br><em><strong>I</strong></em> type:<br>&ldquo;Immediate&rdquo; type - this format is used by arithmetic, logic, and shift operations with immediates, jump and link register, environment calls, and LOAD instructions. (have the longest immediate bits, 11 bits, from 20 to 31)<br>not the only instruction to encode immediate but R type.</p><ol><li>generic register-immediate instruction<br>12 bits immediate, 5 bits rs1, 3 bits funct3, 5 bits rd and 7 bits opcode.</li><li>generic LOAD instruction<br>12 bits immediate, 5 bits rs1, 3 bits funct3, 5 bits rd and 7 bits opcode.</li><li>JALR instruction<br>12 bits immediate, 5 bits rs1, 3 bits funct3, 5 bits rd and 7 bits opcode.</li><li>FENCE instruction<br>4 bits fm, 1 bit PI, PO, PR, PW, SI, SO, SR and SW, 5 bits rs1, 3 bits funct3, 5 bits rd and 7 bits opcode.</li><li>Environment instruction<br>12 bits immediate, 5 bits rs1, 3 bits funct3, 5 bits rd and 7 bits opcode.
<strong>EBREAK</strong> returns control to the debugging environment.<br><strong>ECALL</strong> requests privileged information to the execution environment in ways defined by the applicable EEI.</li><li>pseudoinstructions<br>NOP, LI, MV, SEXT.W, SEQZ, The FENCE instruction without arguments is an alias for FENCE iorw iorw, JR, JALR and RET.<br><em><strong>S</strong></em> type:<br>&ldquo;Store&rdquo; type - this format is used by the STORE instructions.<br>same structure as B<br><em><strong>B</strong></em> type:<br>&ldquo;Branch&rdquo; type - this format is used by the BRANCH instructions.<br>same structure as S<br><em><strong>U</strong></em> type:<br>&ldquo;Upper Immediate&rdquo; type - this format is used by instructions that use upper immediates (LUI and AUIPC).<br>same structure as J<br>20 bits immediates, 5 bits rd and 7 bits opcode.<br>AUIPC rd imm &ldquo;add upper immediate to PC&rdquo; stores the value of PC in rd and adds the shifted imm to it.<br>LUI rd imm &ldquo;load upper immediate&rdquo; set rd to the shifted imm.<br><em><strong>J</strong></em> type:<br>&ldquo;Jump&rdquo; type - this format is used by the JAL (jump and link) instruction.<br>same structure as U<br>JAL rd imm &ldquo;jump and link&rdquo;:<br>save PC+4, the return address associated with the JAL instruction, in rd.<br>Add imm to PC.</li></ol><h4 id=summary>summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h4><p>The J-type instructions have the same structure as the U-type instructions, only differing by how the immediate is encoded.</p><h3 id=register>register<a hidden class=anchor aria-hidden=true href=#register>#</a></h3><p>More: RISC processors usually have more than eight general-purpose registers.</p><h3 id=memory>memory<a hidden class=anchor aria-hidden=true href=#memory>#</a></h3><p>Memory access is limited to Load and Store instructions.</p><h4 id=virtual-memory>virtual memory<a hidden class=anchor aria-hidden=true href=#virtual-memory>#</a></h4><ol><li>single address space</li><li>divided into pages, 4 kilobytes long sections of continuous memory.</li><li>isolates software running above it requiring addresses to be translated by the operating system.</li></ol><h3 id=feature>feature<a hidden class=anchor aria-hidden=true href=#feature>#</a></h3><p>modular: base(I must exist) + extensions</p><h3 id=spec>spec<a hidden class=anchor aria-hidden=true href=#spec>#</a></h3><p>ISA specifications:<br>priviledged + unprivileged<br>unprivileged: Base ISA and ISA extensions<br>privileged: interrupts, exceptions, virtual memory management, and physical memory protection etc</p><h3 id=software-stack>software stack<a hidden class=anchor aria-hidden=true href=#software-stack>#</a></h3><p>ABI(specification) -> application<br>SBI(specification) -> supervisor(application)<br>HBI(specification) -> hypervisor(application)<br>AEE<br>SEE<br>HEE</p><h3 id=risc-v-isa-privilegde-mode>RISC-V ISA privilegde mode<a hidden class=anchor aria-hidden=true href=#risc-v-isa-privilegde-mode>#</a></h3><p><strong>M</strong> (machine) mode<br><strong>S</strong> (supervisor) mode<br><strong>U</strong> (user) mode</p><h3 id=traps>traps<a hidden class=anchor aria-hidden=true href=#traps>#</a></h3><h4 id=contained-trap>contained trap<a hidden class=anchor aria-hidden=true href=#contained-trap>#</a></h4><p>Handled by the <strong>software that raise it</strong>.<br>Execution resumes after resolution.</p><h4 id=requested-trap>requested trap<a hidden class=anchor aria-hidden=true href=#requested-trap>#</a></h4><p>request to execution environment.</p><h4 id=invisible-trap>invisible trap<a hidden class=anchor aria-hidden=true href=#invisible-trap>#</a></h4><p>raised and handled by the execution environment.<br>not visible by the software running inside it.</p><h4 id=fatal-trap>fatal trap<a hidden class=anchor aria-hidden=true href=#fatal-trap>#</a></h4><p>cause the execution environment to stop exeception.</p><h3 id=csr>CSR<a hidden class=anchor aria-hidden=true href=#csr>#</a></h3><h4 id=acronyms>Acronyms<a hidden class=anchor aria-hidden=true href=#acronyms>#</a></h4><p><strong>WPRI</strong>: write preserve, read ignore.<br><strong>WLRL</strong>: write legal, read legal.<br><strong>WARL</strong>: write any, read legal.</p><h4 id=machine-level-isa>Machine Level ISA<a hidden class=anchor aria-hidden=true href=#machine-level-isa>#</a></h4><h5 id=mstatus>mstatus<a hidden class=anchor aria-hidden=true href=#mstatus>#</a></h5><p>register.<br>always 64 bits wide. RV32 machine implement it as two separate CSRs (mstatus and mstatush)<br><strong>xIE</strong>: x mode <strong>I</strong>nterrupt <strong>E</strong>nabled<br><strong>xPIE</strong>: x mode <strong>P</strong>revious <strong>I</strong>nterrupt <strong>E</strong>nabled<br><strong>xPP</strong>: x mode <strong>P</strong>revious <strong>P</strong>rivilege<br>x can be M or S mode</p><h5 id=mip>mip<a hidden class=anchor aria-hidden=true href=#mip>#</a></h5><p><strong>M</strong>achine <strong>I</strong>nterrupt <strong>P</strong>ending WARL register</p><h5 id=mie>mie<a hidden class=anchor aria-hidden=true href=#mie>#</a></h5><p><strong>M</strong>achine <strong>I</strong>nterrupt <strong>E</strong>nable WARL register</p><h5 id=mepc>mepc<a hidden class=anchor aria-hidden=true href=#mepc>#</a></h5><p><strong>M</strong>achine <strong>E</strong>xception <strong>P</strong>rogram <strong>C</strong>ounter WARL register</p><h5 id=mcause>mcause<a hidden class=anchor aria-hidden=true href=#mcause>#</a></h5><p><strong>M</strong>achine <strong>C</strong>ause WLRL register</p><h5 id=mtval>mtval<a hidden class=anchor aria-hidden=true href=#mtval>#</a></h5><p><strong>M</strong>achine <strong>T</strong>rap <strong>Val</strong>ue register</p><h5 id=mconfigptr>mconfigptr<a hidden class=anchor aria-hidden=true href=#mconfigptr>#</a></h5><p><strong>M</strong>achine <strong>Config</strong>uration <strong>P</strong>oin<strong>t</strong>e<strong>r</strong><br>address</p><h5 id=i-type-format-instructions-to-enable-trap-handling>I-type format instructions to enable trap handling<a hidden class=anchor aria-hidden=true href=#i-type-format-instructions-to-enable-trap-handling>#</a></h5><p><strong>MRET</strong>: M mode return<br><strong>WFI</strong>: Wait for Interrupt</p><h4 id=supervisor-level>Supervisor level<a hidden class=anchor aria-hidden=true href=#supervisor-level>#</a></h4><h5 id=sstatus-sip-sie-scause>sstatus, sip, sie, scause<a hidden class=anchor aria-hidden=true href=#sstatus-sip-sie-scause>#</a></h5><p>same as mstatus, mip, mie, mcause.</p><h5 id=sepc-stval>sepc, stval<a hidden class=anchor aria-hidden=true href=#sepc-stval>#</a></h5><p>same as mepc and mtval, except they contain virtual rather than physical memory addresses.</p><h5 id=satp>satp<a hidden class=anchor aria-hidden=true href=#satp>#</a></h5><p><strong>S</strong>upervisor <strong>A</strong>ddress <strong>T</strong>ranslation and <strong>P</strong>rotection register has no Machine Level equivalent<br>it is used for memory address translation.<br><strong>MODE</strong><br><strong>ASID</strong><br><strong>A</strong>ddress <strong>S</strong>pace <strong>ID</strong>entifier<br><strong>PPN</strong><br><strong>P</strong>hysical <strong>P</strong>age <strong>N</strong>umber</p><h4 id=hypervisor>Hypervisor<a hidden class=anchor aria-hidden=true href=#hypervisor>#</a></h4><h4 id=memory-model>memory model<a hidden class=anchor aria-hidden=true href=#memory-model>#</a></h4><h5 id=rvwmo>RVWMO<a hidden class=anchor aria-hidden=true href=#rvwmo>#</a></h5><p><strong>R</strong>ISC-V <strong>W</strong>eak <strong>M</strong>emory <strong>O</strong>rdering</p><h5 id=pmp>PMP<a hidden class=anchor aria-hidden=true href=#pmp>#</a></h5><p><strong>P</strong>hysical <strong>M</strong>emory <strong>P</strong>rotection</p><h3 id=assembly>Assembly<a hidden class=anchor aria-hidden=true href=#assembly>#</a></h3><h4 id=interrupt-handler>interrupt handler<a hidden class=anchor aria-hidden=true href=#interrupt-handler>#</a></h4><p>__attribute_<em>((interrupt(&ldquo;machine&rdquo;)))<br>__attribute_</em>((interrupt(&ldquo;supervisor&rdquo;)))</p><h4 id=call-convention>call convention<a hidden class=anchor aria-hidden=true href=#call-convention>#</a></h4><p>register <strong>s0</strong> is callee register, the function that is called should be responsible for (re)storing it.</p><h3 id=gcc>GCC<a hidden class=anchor aria-hidden=true href=#gcc>#</a></h3><h4 id=compiler-flags>compiler flags<a hidden class=anchor aria-hidden=true href=#compiler-flags>#</a></h4><h5 id=code-model>code model<a hidden class=anchor aria-hidden=true href=#code-model>#</a></h5><p><strong>-mcmodel</strong>:<br>-mcmodel=medlow:<br>address range is within 2 GiB in the absolute range between -2 GiB and +2 GiB<br>-mcmodel=medany:<br>an address range within 2 GiB but position-independent<br><strong>linker relaxation</strong>:<br>used by the linker to efficiently load symbol addresses.<br>-mrelax:enable linker relaxations<br>-mno-relax:disable linker relaxations</p><h3 id=llvm>LLVM<a hidden class=anchor aria-hidden=true href=#llvm>#</a></h3><h3 id=operate-system>operate system<a hidden class=anchor aria-hidden=true href=#operate-system>#</a></h3><h4 id=amo>AMO<a hidden class=anchor aria-hidden=true href=#amo>#</a></h4><p><strong>R-type</strong> instruction format.</p><p>atomic swap instrution can be used to atomically acquire and release locks.<br>atomic load-and-reserve and store-conditional instructions can be used to implement semaphores.</p><h4 id=high-level-atomic-api>High-Level Atomic API<a hidden class=anchor aria-hidden=true href=#high-level-atomic-api>#</a></h4><h5 id=mutex>Mutex<a hidden class=anchor aria-hidden=true href=#mutex>#</a></h5><p>A mutex is a lock that provides mutual exclusion to a shared resource.<br>A spinlock is a lock that uses busy waiting to synchronize access to a shared resource.</p><h5 id=semaphores>Semaphores<a hidden class=anchor aria-hidden=true href=#semaphores>#</a></h5><p>Data structure. A semaphore is one synchronization mechanism used in most OSes to control access to shared resources.</p><h5 id=monitors>Monitors<a hidden class=anchor aria-hidden=true href=#monitors>#</a></h5><h5 id=sendrecv>Send/Recv<a hidden class=anchor aria-hidden=true href=#sendrecv>#</a></h5><h4 id=low-level-atomic-ops>Low-Level Atomic Ops<a hidden class=anchor aria-hidden=true href=#low-level-atomic-ops>#</a></h4><h5 id=loadstore>Load/store<a hidden class=anchor aria-hidden=true href=#loadstore>#</a></h5><h5 id=interrupt-disableenable>Interrupt disable/enable<a hidden class=anchor aria-hidden=true href=#interrupt-disableenable>#</a></h5><h5 id=testset>Test&amp;Set<a hidden class=anchor aria-hidden=true href=#testset>#</a></h5><h5 id=other-atomic-instructions>Other atomic instructions<a hidden class=anchor aria-hidden=true href=#other-atomic-instructions>#</a></h5><h4 id=interruptsio-multiprocessors-and-cpu-scheduling>Interrupts(I/O), Multiprocessors and CPU scheduling<a hidden class=anchor aria-hidden=true href=#interruptsio-multiprocessors-and-cpu-scheduling>#</a></h4><h4 id=synchronization>Synchronization<a hidden class=anchor aria-hidden=true href=#synchronization>#</a></h4><p>Load-linked/store-conditional(<strong>LL/SC</strong>):<br>Generally, LR will return the current value of an address, and a subsequent SC to the same address will store a new value only if no updates have occurred to the same address since the last LR.<br>Load-reserved/store-conditional(<strong>LR/SC</strong>):<br>If the SC.W <strong>succeeds</strong>, the instruction writes the word in rs2 to memory, and it <strong>writes zero</strong> to rd.<br>If the SC.W <strong>fails</strong>, the instruction does not write to memory, and it <strong>writes a nonzero value</strong> to rd.</p><h3 id=general-purpose-operate-system>general purpose operate system<a hidden class=anchor aria-hidden=true href=#general-purpose-operate-system>#</a></h3><h5 id=smap>SMAP<a hidden class=anchor aria-hidden=true href=#smap>#</a></h5><p>Supervisor Mode Access Prevention<br>SMAP is a hardware-based feature that prevents the kernel from accessing user-level memory.</p><h5 id=smep>SMEP<a hidden class=anchor aria-hidden=true href=#smep>#</a></h5><p>Supervisor Mode Execution Prevention<br>Unlike SMAP, which can be configured, SMEP is always enabled in RISC-V when paged virtual memory is enabled.</p><h3 id=tips>tips<a hidden class=anchor aria-hidden=true href=#tips>#</a></h3><ol><li>The OpenRISC ISA is the first open ISA.</li><li>There are instruction set specifications for 32-bit and 64-bit address spaces, but the RISC-V design allows for <strong>any bit-width</strong> address spaces.</li><li>AUIPC+JALR or LUI+JALR combo make absolute addressing achievable, so a program can unconditionally jump to any absolute address in the whole memory address space. not recommend.</li><li>RISC-V support <strong>hypervisor nesting</strong>(running a hypervisor on top of another hypervisor) with the Hypervisor extension.</li></ol></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://xyenchi.github.io/>xyenchi's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>